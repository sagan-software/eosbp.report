// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Url = require("url");
var Path = require("path");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Eosjs = require("eosjs");
var Json5 = require("json5");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Mkdirp = require("mkdirp");
var Npmlog = require("npmlog");
var Process = require("process");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var BignumberJs = require("bignumber.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Env$ReactTemplate = require("../src/Env.js");
var Request$ReactTemplate = require("../src/Request.js");
var EosBp_Json$ReactTemplate = require("../src/EosBp_Json.js");
var EosBp_Table$ReactTemplate = require("../src/EosBp_Table.js");

((process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'));

var BadUrl = Caml_exceptions.create("Fetch_json-ReactTemplate.BadUrl");

function fetchWithUrl(url, method__, body, $staropt$star, _) {
  var timeout = $staropt$star !== undefined ? $staropt$star : 5000;
  var urlStr = url.toString();
  return Request$ReactTemplate.make(urlStr, method__, false, body, timeout, undefined, /* () */0).then((function (res) {
                return Promise.resolve(/* record */[
                            /* requestUrl */urlStr,
                            /* responseUrl */res.request.uri.href,
                            /* statusCode */res.statusCode,
                            /* statusText */res.statusMessage,
                            /* contentType */Request$ReactTemplate.header(res, "Content-Type"),
                            /* text */res.body
                          ]);
              }));
}

function fetchWithBase(baseUrl, path, method__, body, timeout, _) {
  var exit = 0;
  var url;
  try {
    url = new Url.URL(path, baseUrl);
    exit = 1;
  }
  catch (_error){
    return Promise.reject([
                BadUrl,
                baseUrl
              ]);
  }
  if (exit === 1) {
    return fetchWithUrl(url, method__, body, timeout, /* () */0);
  }
  
}

function fetch(url, method__, body, timeout, _) {
  var exit = 0;
  var url$1;
  try {
    url$1 = new Url.URL(url);
    exit = 1;
  }
  catch (_error){
    return Promise.reject([
                BadUrl,
                url
              ]);
  }
  if (exit === 1) {
    return fetchWithUrl(url$1, method__, body, timeout, /* () */0);
  }
  
}

function decodeAsResult(decoder, json) {
  var exit = 0;
  var decoded;
  try {
    decoded = Curry._1(decoder, json);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Json_decode.DecodeError) {
      return /* Error */Block.__(1, [exn[1]]);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return /* Ok */Block.__(0, [decoded]);
  }
  
}

function parseData(decoder, text) {
  var exit = 0;
  var json;
  try {
    json = JSON.parse(text);
    exit = 1;
  }
  catch (_error){
    var json$1 = Json5.parse(text);
    return /* record */[
            /* json */json$1,
            /* isJson5 */false,
            /* decoded */decodeAsResult(decoder, json$1)
          ];
  }
  if (exit === 1) {
    return /* record */[
            /* json */json,
            /* isJson5 */false,
            /* decoded */decodeAsResult(decoder, json)
          ];
  }
  
}

var InvalidJson = Caml_exceptions.create("Fetch_json-ReactTemplate.InvalidJson");

function thenDecode(decoder, promise) {
  return promise.then((function (response) {
                var exit = 0;
                var data;
                try {
                  data = parseData(decoder, response[/* text */5]);
                  exit = 1;
                }
                catch (exn){
                  return Promise.reject([
                              InvalidJson,
                              response
                            ]);
                }
                if (exit === 1) {
                  return Promise.resolve(/* tuple */[
                              response,
                              data
                            ]);
                }
                
              }));
}

var DecodeError = Caml_exceptions.create("Fetch_json-ReactTemplate.DecodeError");

function requireDecoded(promise) {
  return promise.then((function (param) {
                var data = param[1];
                var response = param[0];
                var match = data[/* decoded */2];
                if (match.tag) {
                  return Promise.reject([
                              DecodeError,
                              response,
                              match[0]
                            ]);
                } else {
                  return Promise.resolve(/* tuple */[
                              response,
                              data,
                              match[0]
                            ]);
                }
              }));
}

var BigNumber = /* module */[];

function tableRowsRaw(httpEndpoint, lowerBound, _) {
  var body = JSON.stringify(Json_encode.object_(/* :: */[
            /* tuple */[
              "scope",
              "eosio"
            ],
            /* :: */[
              /* tuple */[
                "code",
                "eosio"
              ],
              /* :: */[
                /* tuple */[
                  "table",
                  "producers"
                ],
                /* :: */[
                  /* tuple */[
                    "json",
                    true
                  ],
                  /* :: */[
                    /* tuple */[
                      "limit",
                      100
                    ],
                    /* :: */[
                      /* tuple */[
                        "lower_bound",
                        Js_option.getWithDefault("", lowerBound)
                      ],
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ]
          ]));
  return fetchWithBase(httpEndpoint, "/v1/chain/get_table_rows", "POST", body, undefined, /* () */0);
}

function tableRows(httpEndpoint, lowerBound, _) {
  return requireDecoded(thenDecode(EosBp_Table$ReactTemplate.decode, tableRowsRaw(httpEndpoint, lowerBound, /* () */0))).then((function (param) {
                var table = param[2];
                var data = param[1];
                var response = param[0];
                var total = table[/* rows */0].length;
                var more = table[/* more */1];
                Npmlog.info("regproducer", "total=" + (String(total) + (" more=" + (String(more) + ""))), "");
                if (more) {
                  var lastIndex = table[/* rows */0].length - 1 | 0;
                  var lastRow = Belt_Array.get(table[/* rows */0], lastIndex);
                  if (lastRow !== undefined) {
                    var nextLowerBound = new BignumberJs(Eosjs.modules.format.encodeName(lastRow[/* owner */0], false)).plus(1).toString();
                    return tableRows(httpEndpoint, nextLowerBound, /* () */0).then((function (param) {
                                  var t2 = param[2];
                                  var newTable_000 = /* rows */t2[/* rows */0].concat(table[/* rows */0]);
                                  var newTable_001 = /* more */t2[/* more */1];
                                  var newTable = /* record */[
                                    newTable_000,
                                    newTable_001
                                  ];
                                  return Promise.resolve(/* tuple */[
                                              param[0],
                                              param[1],
                                              newTable
                                            ]);
                                }));
                  } else {
                    return Promise.resolve(/* tuple */[
                                response,
                                data,
                                table
                              ]);
                  }
                } else {
                  return Promise.resolve(/* tuple */[
                              response,
                              data,
                              table
                            ]);
                }
              }));
}

function bpJsonRaw(row) {
  var match = row[/* url */4].replace((/\W/g), "").trim().length > 0;
  if (match) {
    var url = EosBp_Table$ReactTemplate.Row[/* jsonUrl */2](row);
    return fetch(url, undefined, undefined, undefined, /* () */0);
  } else {
    return Promise.reject([
                BadUrl,
                row[/* url */4]
              ]);
  }
}

function bpJson(row) {
  return thenDecode(EosBp_Json$ReactTemplate.decode, bpJsonRaw(row));
}

var httpEndpoint = "http://node2.liquideos.com";

function writeBpJson(param) {
  var row = param[2];
  var dirname = Path.join(Env$ReactTemplate.buildDir, row[/* owner */0]);
  Mkdirp.sync(dirname);
  Fs.writeFileSync(Path.join(dirname, "bp-raw.json"), param[0][/* text */5], "utf8");
  Fs.writeFileSync(Path.join(dirname, "bp.json"), JSON.stringify(param[1][/* json */0], null, 2), "utf8");
  Npmlog.info("write", row[/* owner */0], Path.relative(Process.cwd(), dirname));
  return Promise.resolve(/* () */0);
}

function chunks(size, originalArr) {
  var results = /* array */[];
  var arr = originalArr.slice();
  while(arr.length > 0) {
    var chunk = arr.splice(0, size);
    results.push(chunk);
  };
  return results;
}

function allChunked(arr, fn, chunkSize) {
  return chunks(chunkSize, arr).reduce((function (promise, chunk) {
                return promise.then((function (allResults) {
                              return Promise.all(chunk.map(Curry.__1(fn))).then((function (results) {
                                            return Promise.resolve(results.concat(allResults));
                                          }));
                            }));
              }), Promise.resolve(/* array */[]));
}

var Unreachable = Caml_exceptions.create("Fetch_json-ReactTemplate.Unreachable");

var BadResponse = Caml_exceptions.create("Fetch_json-ReactTemplate.BadResponse");

var BadStatus = Caml_exceptions.create("Fetch_json-ReactTemplate.BadStatus");

function handleBpJsonError(match) {
  if (Caml_exceptions.isCamlExceptionOrOpenVariant(match)) {
    if (match[0] === BadUrl) {
      return "Bad URL: \"" + (String(match[1]) + "\"");
    } else if (match[0] === BadStatus) {
      var match$1 = match[1];
      return "Bad status: " + (String(match$1[/* statusCode */2]) + (" (" + (String(match$1[/* statusText */3]) + (") at " + (String(match$1[/* responseUrl */1]) + "")))));
    } else {
      return undefined;
    }
  }
  
}

function fetchBpJson(row) {
  return thenDecode(EosBp_Json$ReactTemplate.decode, bpJsonRaw(row)).then((function (param) {
                  var response = param[0];
                  if (200 <= response[/* statusCode */2] && response[/* statusCode */2] < 400) {
                    Npmlog.info("bp.json", row[/* owner */0], response[/* responseUrl */1]);
                    return Promise.resolve(/* tuple */[
                                response,
                                param[1],
                                row
                              ]);
                  } else {
                    return Promise.reject([
                                BadStatus,
                                response
                              ]);
                  }
                })).catch((function (error) {
                var match = handleBpJsonError(error);
                if (match !== undefined) {
                  Npmlog.error("bp.json", row[/* owner */0], match);
                }
                return Promise.resolve(undefined);
              }));
}

function withoutNone(optsArray) {
  return optsArray.reduce((function (results, item) {
                if (item !== undefined) {
                  results.push(Js_primitive.valFromOption(item));
                }
                return results;
              }), /* array */[]);
}

tableRows(httpEndpoint, undefined, /* () */0).then((function (param) {
              var table = param[2];
              Npmlog.info("regproducer", "total", table[/* rows */0].length);
              return allChunked(table[/* rows */0], fetchBpJson, 25).then((function (responses) {
                              return Promise.resolve(withoutNone(responses));
                            })).then((function (responses) {
                            return Promise.resolve(/* tuple */[
                                        table[/* rows */0],
                                        responses
                                      ]);
                          }));
            })).then((function (param) {
            var responses = param[1];
            var numRows = param[0].length;
            var numResponses = responses.length;
            Npmlog.info("fetch done", "Got " + (String(numResponses) + (" OK responses of " + (String(numRows) + " producers"))), "");
            return allChunked(responses, writeBpJson, 10);
          })).then((function () {
          Npmlog.info("", "Done", Env$ReactTemplate.buildDir);
          return Promise.resolve(/* () */0);
        })).catch((function (error) {
        Npmlog.error("err", "", error);
        return Promise.resolve(/* () */0);
      }));

var Log = 0;

exports.Log = Log;
exports.BadUrl = BadUrl;
exports.fetchWithUrl = fetchWithUrl;
exports.fetchWithBase = fetchWithBase;
exports.fetch = fetch;
exports.decodeAsResult = decodeAsResult;
exports.parseData = parseData;
exports.InvalidJson = InvalidJson;
exports.thenDecode = thenDecode;
exports.DecodeError = DecodeError;
exports.requireDecoded = requireDecoded;
exports.BigNumber = BigNumber;
exports.tableRowsRaw = tableRowsRaw;
exports.tableRows = tableRows;
exports.bpJsonRaw = bpJsonRaw;
exports.bpJson = bpJson;
exports.httpEndpoint = httpEndpoint;
exports.writeBpJson = writeBpJson;
exports.chunks = chunks;
exports.allChunked = allChunked;
exports.Unreachable = Unreachable;
exports.BadResponse = BadResponse;
exports.BadStatus = BadStatus;
exports.handleBpJsonError = handleBpJsonError;
exports.fetchBpJson = fetchBpJson;
exports.withoutNone = withoutNone;
/*  Not a pure module */
